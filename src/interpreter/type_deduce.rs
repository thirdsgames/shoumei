use std::collections::{hash_map::Entry, HashMap, HashSet, VecDeque};

use crate::{Diagnostic, DiagnosticResult, ErrorMessage, HelpMessage, HelpType, Severity};

use super::{
    index::{ProjectIndex, SymbolI},
    index_resolve::resolve_symbol,
    parser::{ExpressionP, IdentifierP},
    type_check::{
        AbstractionVariable, BoundVariable, Expression, ExpressionContents, ExpressionT,
        TypeVariable, TypeVariablePrinter,
    },
    type_resolve::{Type, TypeVariableId},
    Location, ModulePath, QualifiedName, Range, Ranged,
};

/// An intermediate result after having documented an expression's types.
#[derive(Debug)]
struct ExprTypeCheck {
    expr: ExpressionT,
    /// When we create a new type variable, we should store its location of definition in this map.
    type_variable_definition_ranges: HashMap<TypeVariableId, Range>,
    assumptions: Assumptions,
    constraints: Constraints,
}

/// A list of assumptions about each variable's type.
/// Assumptions are applied only to the current list of monomorphic and polymorphic variables,
/// i.e. exactly the list of variables introduced by lambda and let statements respectively.
#[derive(Debug, Default)]
struct Assumptions(HashMap<String, Vec<Assumption>>);

impl Assumptions {
    fn new_with(var: String, assumption: Assumption) -> Self {
        let mut map = HashMap::new();
        map.insert(var, vec![assumption]);
        Self(map)
    }

    fn union(mut self, other: Self) -> Self {
        for (ty, mut assumptions) in other.0 {
            match self.0.entry(ty) {
                Entry::Occupied(mut occupied) => occupied.get_mut().append(&mut assumptions),
                Entry::Vacant(vacant) => {
                    vacant.insert(assumptions);
                }
            }
        }
        self
    }
}

/// An assumption records the type variables assigned to a given local variable,
/// such as those local variables generated by `lambda` and `let` statements.
#[derive(Debug)]
struct Assumption(TypeVariableId);

/// A list of constraints between types.
#[derive(Debug, Default)]
struct Constraints(Vec<(TypeVariable, Constraint)>);

impl Constraints {
    fn new_with(ty: TypeVariable, constraint: Constraint) -> Self {
        Self(vec![(ty, constraint)])
    }

    fn union(mut self, mut other: Self) -> Self {
        self.0.append(&mut other.0);
        self
    }
}

/// A constraint about a variable's type, used by the type checker.
#[derive(Debug)]
enum Constraint {
    /// The given type is exactly equal to this type.
    Equality {
        ty: TypeVariable,
        reason: ConstraintEqualityReason,
    },
    /// `ty` must be a generic instance of the polytype `scheme`.
    /// For example, `Maybe Bool` is a generic instance of `Maybe a`.
    ExplicitInstance {
        scheme: TypeVariable,
        reason: ConstraintExplicitReason,
    },
    /// `ty` must be a generic instance of the polytype `scheme`, when
    /// generalising `scheme` with respect to the given monotypes, i.e. generalising
    /// over all the polymorphic type variables.
    ImplicitInstance {
        scheme: TypeVariable,
        monotypes: HashSet<TypeVariableId>,
        reason: ConstraintImplicitReason,
    },
}

#[derive(Debug)]
enum ConstraintEqualityReason {
    /// This constraint was generated as a result of applying a function to a variable.
    Apply {
        /// The function we're invoking.
        function_range: Range,
        function_ty: TypeVariable,
        /// The argument we're supplying.
        argument_range: Range,
        argument_ty: TypeVariable,
    },
    /// This constraint was generated as a result of generating a lambda abstraction's type.
    /// These constraints should probably be solved first if possible, since they're likely
    /// to have really bad error messages.
    LambdaType { lambda: Range },
    /// This constraint was generated as a result of a lambda's parameter being used
    /// in the lambda expression body.
    LambdaParameter { lambda: Range },
    /// This constraint was generated as a result of specifying that a let expression's
    /// type must be equal to the right hand expression's type.
    LetType { let_token: Range, right_expr: Range },
    /// This constraint is a generalised version of an implicit instance constraint.
    Implicit(ConstraintImplicitReason),
    /// This constraint is a generalised version of an explicit instance constraint.
    Explicit(ConstraintExplicitReason),
}

#[derive(Debug)]
enum ConstraintExplicitReason {}

#[derive(Debug)]
enum ConstraintImplicitReason {
    /// This expression is an implicit instance of the variable bound in a let expression.
    InstanceLet { let_token: Range },
}

pub fn deduce_expr_type(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    expr: ExpressionP,
    expected_type: Type,
    quantifiers: &[IdentifierP],
) -> DiagnosticResult<Expression> {
    generate_constraints(
        module_path,
        project_index,
        args,
        HashMap::new(),
        HashMap::new(),
        expr,
    )
    .deny()
    .bind(|expr_type_check| {
        if !expr_type_check.assumptions.0.is_empty() {
            panic!("unresolved assumptions {:#?}", expr_type_check.assumptions);
        }
        solve_type_constraints(
            module_path,
            project_index,
            args,
            &expr_type_check.type_variable_definition_ranges,
            expr_type_check.expr,
            expr_type_check.constraints,
            quantifiers,
        )
    })
}

/// Assigns new type variables to each sub-expression, so that this expression can be easily type checked.
/// This uses the algorithm from <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348> to assign constraints to these type variables.
///
/// Assumptions and constraints will be generated by each sub-expression.
/// `monotype_variables` is the set of variables that we introduced using a lambda expression. Assumptions in the returned value only relate to this
/// set of monotype variables.
/// `polytype_variables` is the set of variables that we introduced using a let expression.
fn generate_constraints(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    mut monotype_variables: HashMap<String, AbstractionVariable>,
    mut polytype_variables: HashMap<String, AbstractionVariable>,
    expr: ExpressionP,
) -> DiagnosticResult<ExprTypeCheck> {
    match expr {
        ExpressionP::Variable(identifier) => {
            // Let's try to work out what this identifier is referring to.
            // First, check the function's arguments.
            if let Some(arg) = args.get(&identifier.name) {
                // We don't need to add an assumption or constraint about this type variable, since it is known.
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: arg.var_type.instantiate(),
                        contents: ExpressionContents::Argument(identifier),
                    },
                    type_variable_definition_ranges: HashMap::new(),
                    assumptions: Assumptions::default(),
                    constraints: Constraints::default(),
                });
            }

            // Now, check the monotype variables.
            if monotype_variables.get(&identifier.name).is_some() {
                let type_variable = TypeVariableId::default();
                let identifier_name = identifier.name.clone();
                let mut type_variable_definition_ranges = HashMap::new();
                type_variable_definition_ranges.insert(type_variable, identifier.range);
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: TypeVariable::Unknown(type_variable),
                        contents: ExpressionContents::MonotypeVariable(identifier),
                    },
                    type_variable_definition_ranges,
                    assumptions: Assumptions::new_with(identifier_name, Assumption(type_variable)),
                    constraints: Constraints::default(),
                });
            }
            // Now, check the polytype variables.
            if polytype_variables.get(&identifier.name).is_some() {
                let type_variable = TypeVariableId::default();
                let identifier_name = identifier.name.clone();
                let mut type_variable_definition_ranges = HashMap::new();
                type_variable_definition_ranges.insert(type_variable, identifier.range);
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: TypeVariable::Unknown(type_variable),
                        contents: ExpressionContents::PolytypeVariable(identifier),
                    },
                    type_variable_definition_ranges,
                    assumptions: Assumptions::new_with(identifier_name, Assumption(type_variable)),
                    constraints: Constraints::default(),
                });
            }

            // Now let's look for a symbol in scope.
            match resolve_symbol(module_path, &identifier, project_index)
                .destructure()
                .0
            {
                Some((symbol_module_path, symbol)) => {
                    // We don't need an assumption, we know what the type of this symbol is.
                    DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: symbol.symbol_type.instantiate(),
                            contents: ExpressionContents::Symbol {
                                name: QualifiedName {
                                    module_path: symbol_module_path.clone(),
                                    name: symbol.name.name.clone(),
                                    range: symbol.name.range,
                                },
                                range: identifier.range,
                            },
                        },
                        type_variable_definition_ranges: HashMap::new(),
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                    })
                }
                // If None, we couldn't find a symbol in scope.
                None => DiagnosticResult::fail(ErrorMessage::new(
                    format!("variable `{}` not recognised", identifier.name),
                    Severity::Error,
                    Diagnostic::at(module_path.clone(), identifier.range),
                )),
            }
        }
        ExpressionP::Apply(left, right) => {
            generate_constraints(
                module_path,
                project_index,
                args,
                monotype_variables.clone(),
                polytype_variables.clone(),
                *left,
            )
            .bind(|left| {
                generate_constraints(
                    module_path,
                    project_index,
                    args,
                    monotype_variables,
                    polytype_variables,
                    *right,
                )
                .map(|right| {
                    let left_type = left.expr.type_variable.clone();
                    let right_type = right.expr.type_variable.clone();
                    let result_type = TypeVariable::Unknown(TypeVariableId::default());

                    let function_range = left.expr.contents.range();
                    let argument_range = right.expr.contents.range();
                    let function_ty = left.expr.type_variable.clone();
                    let argument_ty = right.expr.type_variable.clone();

                    // This expression was: left_type right_type : result_type
                    // Constraint: left_type === right_type -> result_type
                    let mut type_variable_definition_ranges = HashMap::new();
                    type_variable_definition_ranges.extend(left.type_variable_definition_ranges);
                    type_variable_definition_ranges.extend(right.type_variable_definition_ranges);
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: result_type.clone(),
                            contents: ExpressionContents::Apply(
                                Box::new(left.expr),
                                Box::new(right.expr),
                            ),
                        },
                        type_variable_definition_ranges,
                        assumptions: left.assumptions.union(right.assumptions),
                        constraints: left.constraints.union(right.constraints).union(
                            Constraints::new_with(
                                left_type,
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(right_type),
                                        Box::new(result_type),
                                    ),
                                    reason: ConstraintEqualityReason::Apply {
                                        function_range,
                                        argument_range,
                                        function_ty,
                                        argument_ty,
                                    },
                                },
                            ),
                        ),
                    }
                })
            })
        }
        ExpressionP::Unknown(range) => DiagnosticResult::fail(ErrorMessage::new(
            String::from("underscore not allowed in expressions"),
            Severity::Error,
            Diagnostic::at(module_path.clone(), range),
        )),
        ExpressionP::Lambda {
            lambda_token,
            params,
            expr,
        } => {
            // This introduces new monotype variables, so we'll need to edit the `monotype_variables` map.
            let mut messages = Vec::new();
            let mut param_types = Vec::new();
            let mut type_variable_definition_ranges = HashMap::new();

            for param in &params {
                let IdentifierP { name, range } = param;
                match monotype_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(module_path, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        if let Some(previous) = polytype_variables.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        let param_type = TypeVariableId::default();
                        param_types.push(param_type);
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: param_type,
                        });
                        type_variable_definition_ranges.insert(param_type, *range);
                    }
                }
            }

            DiagnosticResult::ok_with_many(monotype_variables, messages)
                .deny()
                .bind(|monotype_variables| {
                    generate_constraints(
                        module_path,
                        project_index,
                        args,
                        monotype_variables,
                        polytype_variables,
                        *expr,
                    )
                    .map(|mut expr| {
                        //let type_variable = TypeVariable::Unknown(TypeVariableId::default());

                        // First, add the constraint that this lambda abstraction's type is input_types -> expr.type.
                        // Gradually process the params to this function, curring each at a time, to get a resultant type variable.
                        let mut lambda_type = expr.expr.type_variable.clone();
                        for param in param_types.iter().rev() {
                            let lambda_step_type = TypeVariable::Unknown(TypeVariableId::default());
                            expr.constraints.0.push((
                                lambda_step_type.clone(),
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(TypeVariable::Unknown(*param)),
                                        Box::new(lambda_type),
                                    ),
                                    reason: ConstraintEqualityReason::LambdaType {
                                        lambda: lambda_token,
                                    },
                                },
                            ));
                            lambda_type = lambda_step_type;
                        }
                        /*expr.constraints
                        .0
                        .push((type_variable.clone(), Constraint::Equality {
                            ty: lambda_type,
                            reason: (),
                        }));*/

                        // Let's now remove and process the assumptions about the parameters.
                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let param_assumptions = params
                            .iter()
                            .map(|param| expr.assumptions.0.remove(&param.name))
                            .map(|option| option.unwrap_or(vec![]))
                            .collect::<Vec<_>>();
                        for (assumptions, param_type) in
                            param_assumptions.into_iter().zip(param_types)
                        {
                            for assumption in assumptions {
                                expr.constraints.0.push((
                                    TypeVariable::Unknown(param_type),
                                    Constraint::Equality {
                                        ty: TypeVariable::Unknown(assumption.0),
                                        reason: ConstraintEqualityReason::LambdaParameter {
                                            lambda: lambda_token,
                                        },
                                    },
                                ));
                            }
                        }

                        type_variable_definition_ranges
                            .extend(expr.type_variable_definition_ranges);

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable: lambda_type,
                                contents: ExpressionContents::Lambda {
                                    lambda_token,
                                    params,
                                    expr: Box::new(expr.expr),
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions: expr.assumptions,
                            constraints: expr.constraints,
                        }
                    })
                })
        }
        ExpressionP::Let {
            let_token,
            identifier,
            left_expr,
            right_expr,
        } => {
            generate_constraints(
                module_path,
                project_index,
                args,
                monotype_variables.clone(),
                polytype_variables.clone(),
                *left_expr,
            )
            .bind(|left_expr| {
                // This introduces new polytype variables, so we'll need to edit the `polytype_variables` map.
                let mut messages = Vec::new();
                let identifier_type = TypeVariableId::default();
                let mut type_variable_definition_ranges = HashMap::new();

                let IdentifierP { name, range } = &identifier;
                match polytype_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(module_path, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        if let Some(previous) = monotype_variables.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: identifier_type,
                        });
                        type_variable_definition_ranges.insert(identifier_type, *range);
                    }
                }

                DiagnosticResult::ok_with_many((), messages).bind(|_| {
                    generate_constraints(
                        module_path,
                        project_index,
                        args,
                        monotype_variables.clone(),
                        polytype_variables.clone(),
                        *right_expr,
                    )
                    .map(|mut right_expr| {
                        // First, let's remove and store the assumptions about the variable that we created in this let statement.
                        let let_assumptions = right_expr
                            .assumptions
                            .0
                            .remove(&identifier.name)
                            .unwrap_or_else(Vec::new);

                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let mut constraints = left_expr.constraints.union(right_expr.constraints);

                        constraints.0.push((
                            TypeVariable::Unknown(identifier_type),
                            Constraint::Equality {
                                ty: left_expr.expr.type_variable.clone(),
                                reason: ConstraintEqualityReason::LetType {
                                    let_token,
                                    right_expr: right_expr.expr.range(),
                                },
                            },
                        ));

                        for assumption in let_assumptions {
                            constraints.0.push((
                                TypeVariable::Unknown(assumption.0),
                                Constraint::ImplicitInstance {
                                    scheme: TypeVariable::Unknown(identifier_type),
                                    monotypes: monotype_variables
                                        .values()
                                        .map(|monotype| monotype.var_type)
                                        .collect(),
                                    reason: ConstraintImplicitReason::InstanceLet { let_token },
                                },
                            ));
                        }

                        type_variable_definition_ranges
                            .extend(left_expr.type_variable_definition_ranges);
                        type_variable_definition_ranges
                            .extend(right_expr.type_variable_definition_ranges);

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable: right_expr.expr.type_variable.clone(),
                                contents: ExpressionContents::Let {
                                    let_token,
                                    identifier,
                                    left_expr: Box::new(left_expr.expr),
                                    right_expr: Box::new(right_expr.expr),
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions: left_expr.assumptions.union(right_expr.assumptions),
                            constraints,
                        }
                    })
                })
            })
        }
    }
}

/// Returns an error message saying a variable was already defined.
fn already_defined(module_path: &ModulePath, range: Range, previous_range: Range) -> ErrorMessage {
    ErrorMessage::new_with(
        String::from("a variable with this name was already defined"),
        Severity::Error,
        Diagnostic::at(module_path.clone(), range),
        HelpMessage {
            message: String::from("previously defined here"),
            help_type: HelpType::Note,
            diagnostic: Diagnostic::at(module_path.clone(), previous_range),
        },
    )
}

/// Deduces the type of an expression.
/// Any error messages are added to the diagnostic result.
///
/// This mostly implements the algorithm from Generalizing Hindley-Milner Type Inference Algorithms (2002)
/// <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348>.
fn solve_type_constraints(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    type_variable_definition_ranges: &HashMap<TypeVariableId, Range>,
    expr: ExpressionT,
    constraints: Constraints,
    quantifiers: &[IdentifierP],
) -> DiagnosticResult<Expression> {
    //println!("Deducing type of {:#?}", expr);
    //println!("Constraints: {:#?}", constraints);
    // We implement the `SOLVE` algorithm from the above paper.

    // The substitutions are defined to be idempotent, so a map instead of an ordered vec shall suffice.
    let mut substitution = HashMap::<TypeVariableId, TypeVariable>::new();
    let mut constraint_queue = constraints
        .0
        .into_iter()
        .collect::<VecDeque<(TypeVariable, Constraint)>>();
    // To solve the constraints, we will pop entries off the front of the queue, process them, and if needed push them to the back of the queue.
    while let Some((type_variable, constraint)) = constraint_queue.pop_front() {
        match constraint {
            Constraint::Equality { ty: other, reason } => {
                // This constraint specifies that `type_variable === other`.
                // So we'll find the most general unifier between the two types.
                match most_general_unifier(type_variable.clone(), other.clone()) {
                    Ok(mgu) => {
                        // Add this substitution to the list of substitutions,
                        // and also apply the substitution to the current list of constraints.
                        apply_substitution_to_constraints(&mgu, &mut constraint_queue);
                        match unify(substitution.clone(), mgu) {
                            Ok(sub) => {
                                substitution = sub;
                            }
                            Err(error) => {
                                return DiagnosticResult::fail(process_unification_error(
                                    module_path,
                                    type_variable_definition_ranges,
                                    &type_variable,
                                    &other,
                                    error,
                                    quantifiers,
                                    reason,
                                    substitution,
                                ));
                            }
                        }
                    }
                    Err(error) => {
                        return DiagnosticResult::fail(process_unification_error(
                            module_path,
                            type_variable_definition_ranges,
                            &type_variable,
                            &other,
                            error,
                            quantifiers,
                            reason,
                            substitution,
                        ));
                    }
                }
            }
            Constraint::ExplicitInstance { .. } => unimplemented!(),
            Constraint::ImplicitInstance {
                scheme,
                monotypes,
                reason,
            } => {
                // Instantiate the given type scheme with respect to the given monotypes.
                // First, work out what the free variables are in the type scheme.
                let free_scheme = freevars(&scheme);
                let polytype_variables = free_scheme
                    .difference(&monotypes)
                    .copied()
                    .collect::<HashSet<_>>();
                let active = activevars(&constraint_queue);
                if polytype_variables.intersection(&active).next().is_some() {
                    // The variables are still live. Delay solving this constraint.
                    constraint_queue.push_back((
                        type_variable,
                        Constraint::ImplicitInstance {
                            scheme,
                            monotypes,
                            reason,
                        },
                    ));
                } else {
                    // The variables are not live. We can solve this constraint now.
                    // For each polytype variable, generate a new monotype variable to substitute for it.
                    let mut instantiate = HashMap::<TypeVariableId, TypeVariable>::new();
                    for v in polytype_variables {
                        instantiate.insert(v, TypeVariable::Unknown(TypeVariableId::default()));
                    }
                    let mut generalised_instance = type_variable.clone();
                    apply_substitution(&instantiate, &mut generalised_instance);
                    constraint_queue.push_back((
                        type_variable,
                        Constraint::Equality {
                            ty: generalised_instance,
                            reason: ConstraintEqualityReason::Implicit(reason),
                        },
                    ));
                }
            }
        }
    }

    DiagnosticResult::ok(Expression {
        ty: Type::Variable("test".to_string()),
        contents: ExpressionContents::Symbol {
            name: QualifiedName {
                module_path: ModulePath(vec!["test".into()]),
                name: "test".into(),
                range: Location { line: 0, col: 0 }.into(),
            },
            range: Location { line: 0, col: 0 }.into(),
        },
    })
}

/// Process an error message generated by computing the most general unifier for two types.
fn process_unification_error(
    module_path: &ModulePath,
    type_variable_definition_ranges: &HashMap<TypeVariableId, Range>,
    left: &TypeVariable,
    right: &TypeVariable,
    error: UnificationError,
    quantifiers: &[IdentifierP],
    reason: ConstraintEqualityReason,
    substitution: HashMap<TypeVariableId, TypeVariable>,
) -> ErrorMessage {
    let mut ty_printer = TypeVariablePrinter::new(substitution);

    // The constraint reasons we made earlier will help us emit an error.
    let (error_range, help) = match reason {
        ConstraintEqualityReason::Apply {
            function_range,
            function_ty,
            argument_range,
            argument_ty,
        } => {
            let messages = vec![
                HelpMessage {
                    message: format!(
                        "error was raised because we tried to apply this function of type {}...",
                        ty_printer.print(function_ty),
                    ),
                    help_type: HelpType::Note,
                    diagnostic: Diagnostic::at(module_path.clone(), function_range),
                },
                HelpMessage {
                    message: format!(
                        "...to an argument of type {}",
                        ty_printer.print(argument_ty)
                    ),
                    help_type: HelpType::Note,
                    diagnostic: Diagnostic::at(module_path.clone(), argument_range),
                },
            ];
            (function_range, messages)
        }
        _ => (Location { line: 0, col: 0 }.into(), Vec::new()),
    };

    // Now emit the error.
    match error {
        UnificationError::TypeNameMismatch {
            left_name,
            right_name,
        } => {
            /*println!("TVDR: {:#?}", type_variable_definition_ranges);
            println!("Q: {:#?}", quantifiers);
            println!("L R {:#?} {:#?}", left, right);
            // When trying to unify types, two types could not be unified.
            let error_range = if let TypeVariable::Unknown(left_id) = left {
                type_variable_definition_ranges[left_id]
            } else if let TypeVariable::Unknown(right_id) = right {
                type_variable_definition_ranges[right_id]
            } else if let TypeVariable::Known(Type::Variable(left_name)) = left {
                quantifiers
                    .iter()
                    .find(|q| q.name == *left_name)
                    .unwrap()
                    .range
            } else if let TypeVariable::Known(Type::Variable(right_name)) = right {
                quantifiers
                    .iter()
                    .find(|q| q.name == *right_name)
                    .unwrap()
                    .range
            } else {
                Location { line: 0, col: 0 }.into()
            };*/
            ErrorMessage::new_with_many(
                format!("type names {} and {} did not match", left_name, right_name),
                Severity::Error,
                Diagnostic::at(module_path.clone(), error_range),
                help,
            )
        }
        UnificationError::NamedNotFunction { named_ty, func_ty } => ErrorMessage::new_with_many(
            format!(
                "a data type {} was found, but it was expected to be a function of type {}",
                ty_printer.print(named_ty),
                ty_printer.print(func_ty)
            ),
            Severity::Error,
            Diagnostic::at(module_path.clone(), error_range),
            help,
        ),
    }
}

fn freevars(ty: &TypeVariable) -> HashSet<TypeVariableId> {
    match ty {
        TypeVariable::Named { name, parameters } => {
            parameters.iter().map(|ty| freevars(ty)).flatten().collect()
        }
        TypeVariable::Function(l, r) => {
            let mut result = freevars(&l);
            result.extend(freevars(&r));
            result
        }
        TypeVariable::Unknown(x) => {
            let mut result = HashSet::new();
            result.insert(*x);
            result
        }
    }
}

fn activevars(constraint_queue: &VecDeque<(TypeVariable, Constraint)>) -> HashSet<TypeVariableId> {
    let mut result = HashSet::new();
    for (ty, constraint) in constraint_queue {
        result.extend(freevars(ty));
        match constraint {
            Constraint::Equality { ty: other, reason } => {
                result.extend(freevars(other));
            }
            Constraint::ExplicitInstance { .. } => unimplemented!(),
            Constraint::ImplicitInstance {
                scheme,
                monotypes,
                reason,
            } => {
                result.extend(freevars(scheme).intersection(monotypes));
            }
        }
    }
    result
}

fn apply_substitution_to_constraints(
    mgu: &HashMap<TypeVariableId, TypeVariable>,
    constraint_queue: &mut VecDeque<(TypeVariable, Constraint)>,
) {
    for (ty, constraint) in constraint_queue {
        apply_substitution(mgu, ty);
        match constraint {
            Constraint::Equality { ty: other, reason } => apply_substitution(mgu, other),
            Constraint::ExplicitInstance { scheme, reason } => apply_substitution(mgu, scheme),
            Constraint::ImplicitInstance {
                scheme,
                monotypes,
                reason,
            } => {
                apply_substitution(mgu, scheme);
                let original_monotypes = std::mem::take(monotypes);
                monotypes.extend(original_monotypes.into_iter().map(|monotype| {
                    let mut ty = TypeVariable::Unknown(monotype);
                    apply_substitution(mgu, &mut ty);
                    if let TypeVariable::Unknown(monotype) = ty {
                        monotype
                    } else {
                        panic!("substitution converted a monotype into a bound variable");
                    }
                }));
            }
        }
    }
}

fn apply_substitution(sub: &HashMap<TypeVariableId, TypeVariable>, ty: &mut TypeVariable) {
    if let TypeVariable::Unknown(val) = ty {
        if let Some(sub_value) = sub.get(val) {
            *ty = sub_value.clone();
        }
    }
}

enum UnificationError {
    TypeNameMismatch {
        left_name: QualifiedName,
        right_name: QualifiedName,
    },
    /// One type was a named data type, the other type was a function.
    NamedNotFunction {
        named_ty: TypeVariable,
        func_ty: TypeVariable,
    },
}

/// Returns a substitution which unifies the two types. If one could not be found, this is a type error, and None will be returned.
fn most_general_unifier(
    left: TypeVariable,
    right: TypeVariable,
) -> Result<HashMap<TypeVariableId, TypeVariable>, UnificationError> {
    // If one of them is an unknown type variable, just set it to the other one.
    match left {
        TypeVariable::Named {
            name: left_name,
            parameters: left_parameters,
        } => {
            match right {
                TypeVariable::Named {
                    name: right_name,
                    parameters: right_parameters,
                } => {
                    // Both type variables are named types.
                    // Check that they are the same.
                    if left_name == right_name {
                        // Unify the type parameters.
                        // The lists must have equal length, since the names matched.
                        let mut mgu = HashMap::new();
                        for (left_param, right_param) in
                            left_parameters.into_iter().zip(right_parameters)
                        {
                            let inner_mgu = most_general_unifier(left_param, right_param)?;
                            mgu = unify(mgu, inner_mgu)?;
                        }
                        Ok(mgu)
                    } else {
                        Err(UnificationError::TypeNameMismatch {
                            left_name,
                            right_name,
                        })
                    }
                }
                TypeVariable::Unknown(right) => {
                    let mut map = HashMap::new();
                    map.insert(
                        right,
                        TypeVariable::Named {
                            name: left_name,
                            parameters: left_parameters,
                        },
                    );
                    Ok(map)
                }
                TypeVariable::Function(right_param, right_result) => {
                    Err(UnificationError::NamedNotFunction {
                        named_ty: TypeVariable::Named {
                            name: left_name,
                            parameters: left_parameters,
                        },
                        func_ty: TypeVariable::Function(right_param, right_result),
                    })
                }
            }
        }
        TypeVariable::Unknown(left) => {
            let mut map = HashMap::new();
            map.insert(left, right);
            Ok(map)
        }
        TypeVariable::Function(left_param, left_result) => {
            match right {
                TypeVariable::Named { name, parameters } => {
                    Err(UnificationError::NamedNotFunction {
                        func_ty: TypeVariable::Function(left_param, left_result),
                        named_ty: TypeVariable::Named { name, parameters },
                    })
                }
                TypeVariable::Function(right_param, right_result) => {
                    // Both were functions. Unify both the parameters and the results.
                    let mgu1 = most_general_unifier(*left_param, *right_param)?;
                    let mgu2 = most_general_unifier(*left_result, *right_result)?;
                    unify(mgu1, mgu2)
                }
                TypeVariable::Unknown(right) => {
                    let mut map = HashMap::new();
                    map.insert(right, TypeVariable::Function(left_param, left_result));
                    Ok(map)
                }
            }
        }
    }
}

fn unify(
    mut a: HashMap<TypeVariableId, TypeVariable>,
    b: HashMap<TypeVariableId, TypeVariable>,
) -> Result<HashMap<TypeVariableId, TypeVariable>, UnificationError> {
    for (id, v) in b {
        match a.entry(id) {
            Entry::Occupied(occupied) => {
                let inner_mgu = most_general_unifier(occupied.get().clone(), v)?;
                a = unify(a, inner_mgu)?;
            }
            Entry::Vacant(vacant) => {
                vacant.insert(v);
            }
        }
    }
    Ok(a)
}
