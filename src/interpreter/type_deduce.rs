use std::collections::{hash_map::Entry, HashMap, HashSet, VecDeque};

use crate::{Diagnostic, DiagnosticResult, ErrorMessage, HelpMessage, HelpType, Severity};

use super::{
    index::ProjectIndex,
    index_resolve::resolve_symbol,
    parser::{ExpressionP, IdentifierP},
    type_check::{
        AbstractionVariable, BoundVariable, Expression, ExpressionContents, ExpressionT,
        TypeVariable,
    },
    type_resolve::{Type, TypeVariableId},
    Location, ModulePath, QualifiedName, Range,
};

/// An intermediate result after having documented an expression's types.
#[derive(Debug)]
struct ExprTypeCheck {
    expr: ExpressionT,
    assumptions: Assumptions,
    constraints: Constraints,
}

/// A list of assumptions about each variable's type.
/// Assumptions are applied only to the current list of monomorphic and polymorphic variables,
/// i.e. exactly the list of variables introduced by lambda and let statements respectively.
#[derive(Debug, Default)]
struct Assumptions(HashMap<String, Vec<Assumption>>);

impl Assumptions {
    fn new_with(var: String, assumption: Assumption) -> Self {
        let mut map = HashMap::new();
        map.insert(var, vec![assumption]);
        Self(map)
    }

    fn union(mut self, other: Self) -> Self {
        for (ty, mut assumptions) in other.0 {
            match self.0.entry(ty) {
                Entry::Occupied(mut occupied) => occupied.get_mut().append(&mut assumptions),
                Entry::Vacant(vacant) => {
                    vacant.insert(assumptions);
                }
            }
        }
        self
    }
}

/// An assumption records the type variables assigned to a given local variable,
/// such as those local variables generated by `lambda` and `let` statements.
#[derive(Debug)]
struct Assumption(pub TypeVariableId);

/// A list of constraints between types.
#[derive(Debug, Default)]
pub struct Constraints(pub Vec<(TypeVariable, Constraint)>);

impl Constraints {
    fn new_with(ty: TypeVariable, constraint: Constraint) -> Self {
        Self(vec![(ty, constraint)])
    }

    fn union(mut self, mut other: Self) -> Self {
        self.0.append(&mut other.0);
        self
    }
}

/// A constraint about a variable's type, used by the type checker.
#[derive(Debug)]
pub enum Constraint {
    /// The given type is exactly equal to this type.
    Equality(TypeVariable),
    /// `ty` must be a generic instance of the polytype `scheme`.
    /// For example, `Maybe Bool` is a generic instance of `Maybe a`.
    ExplicitInstance { scheme: TypeVariable },
    /// `ty` must be a generic instance of the polytype `scheme`, when
    /// generalising `scheme` with respect to the given monotypes, i.e. generalising
    /// over all the polymorphic type variables.
    ImplicitInstance {
        scheme: TypeVariable,
        monotypes: HashSet<TypeVariableId>,
    },
}

pub fn deduce_expr_type(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    monotype_variables: HashMap<String, AbstractionVariable>,
    polytype_variables: HashMap<String, AbstractionVariable>,
    expr: ExpressionP,
    expected_type: Type,
) -> DiagnosticResult<Expression> {
    parse_expr(
        module_path,
        project_index,
        args,
        monotype_variables,
        polytype_variables,
        expr,
    )
    .deny()
    .bind(|expr_type_check| {
        if !expr_type_check.assumptions.0.is_empty() {
            panic!("unresolved assumptions {:#?}", expr_type_check.assumptions);
        }
        solve_type_constraints(
            module_path,
            project_index,
            args,
            expr_type_check.expr,
            expr_type_check.constraints,
        )
    })
}

/// Assigns new type variables to each sub-expression, so that this expression can be easily type checked.
/// This uses the algorithm from <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348> to assign constraints to these type variables.
///
/// Assumptions and constraints will be generated by each sub-expression.
/// `monotype_variables` is the set of variables that we introduced using a lambda expression. Assumptions in the returned value only relate to this
/// set of monotype variables.
/// `polytype_variables` is the set of variables that we introduced using a let expression.
fn parse_expr(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    mut monotype_variables: HashMap<String, AbstractionVariable>,
    mut polytype_variables: HashMap<String, AbstractionVariable>,
    expr: ExpressionP,
) -> DiagnosticResult<ExprTypeCheck> {
    match expr {
        ExpressionP::Variable(identifier) => {
            // Let's try to work out what this identifier is referring to.
            // First, check the function's arguments.
            if let Some(arg) = args.get(&identifier.name) {
                // We don't need to add an assumption or constraint about this type variable, since it is known.
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: TypeVariable::Known(arg.var_type.clone()),
                        contents: ExpressionContents::Argument(identifier),
                    },
                    assumptions: Assumptions::default(),
                    constraints: Constraints::default(),
                });
            }

            // Now, check the monotype variables.
            if monotype_variables.get(&identifier.name).is_some() {
                let type_variable = TypeVariableId::default();
                let identifier_name = identifier.name.clone();
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: TypeVariable::Unknown(type_variable),
                        contents: ExpressionContents::MonotypeVariable(identifier),
                    },
                    assumptions: Assumptions::new_with(identifier_name, Assumption(type_variable)),
                    constraints: Constraints::default(),
                });
            }
            // Now, check the polytype variables.
            if polytype_variables.get(&identifier.name).is_some() {
                let type_variable = TypeVariableId::default();
                let identifier_name = identifier.name.clone();
                return DiagnosticResult::ok(ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: TypeVariable::Unknown(type_variable),
                        contents: ExpressionContents::PolytypeVariable(identifier),
                    },
                    assumptions: Assumptions::new_with(identifier_name, Assumption(type_variable)),
                    constraints: Constraints::default(),
                });
            }

            // Now let's look for a symbol in scope.
            match resolve_symbol(module_path, &identifier, project_index)
                .destructure()
                .0
            {
                Some((symbol_module_path, symbol)) => {
                    // We don't need an assumption, we know what the type of this symbol is.
                    DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Known(symbol.symbol_type.clone()),
                            contents: ExpressionContents::Symbol(QualifiedName {
                                module_path: symbol_module_path.clone(),
                                name: symbol.name.name.clone(),
                                range: symbol.name.range,
                            }),
                        },
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                    })
                }
                // If None, we couldn't find a symbol in scope.
                None => DiagnosticResult::fail(ErrorMessage::new(
                    format!("variable `{}` not recognised", identifier.name),
                    Severity::Error,
                    Diagnostic::at(module_path.clone(), identifier.range),
                )),
            }
        }
        ExpressionP::Apply(left, right) => {
            parse_expr(
                module_path,
                project_index,
                args,
                monotype_variables.clone(),
                polytype_variables.clone(),
                *left,
            )
            .bind(|left| {
                parse_expr(
                    module_path,
                    project_index,
                    args,
                    monotype_variables,
                    polytype_variables,
                    *right,
                )
                .map(|right| {
                    let left_type = left.expr.type_variable.clone();
                    let right_type = right.expr.type_variable.clone();
                    let result_type = TypeVariable::Unknown(TypeVariableId::default());
                    // This expression was: left_type right_type : result_type
                    // Constraint: left_type === right_type -> result_type
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: result_type.clone(),
                            contents: ExpressionContents::Apply(
                                Box::new(left.expr),
                                Box::new(right.expr),
                            ),
                        },
                        assumptions: left.assumptions.union(right.assumptions),
                        constraints: left.constraints.union(right.constraints).union(
                            Constraints::new_with(
                                left_type,
                                Constraint::Equality(TypeVariable::Function(
                                    Box::new(right_type),
                                    Box::new(result_type),
                                )),
                            ),
                        ),
                    }
                })
            })
        }
        ExpressionP::Unknown(range) => DiagnosticResult::fail(ErrorMessage::new(
            String::from("underscore not allowed in expressions"),
            Severity::Error,
            Diagnostic::at(module_path.clone(), range),
        )),
        ExpressionP::Lambda { params, expr, .. } => {
            // This introduces new monotype variables, so we'll need to edit the `monotype_variables` map.
            let mut messages = Vec::new();
            let mut param_types = Vec::new();

            for param in &params {
                let IdentifierP { name, range } = param;
                match monotype_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(module_path, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        if let Some(previous) = polytype_variables.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        let param_type = TypeVariableId::default();
                        param_types.push(param_type);
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: param_type,
                        });
                    }
                }
            }

            DiagnosticResult::ok_with_many(monotype_variables, messages)
                .deny()
                .bind(|monotype_variables| {
                    parse_expr(
                        module_path,
                        project_index,
                        args,
                        monotype_variables,
                        polytype_variables,
                        *expr,
                    )
                    .map(|mut expr| {
                        let type_variable = TypeVariable::Unknown(TypeVariableId::default());

                        // First, add the constraint that this lambda abstraction's type is input_types -> expr.type.
                        // Gradually process the params to this function, curring each at a time, to get a resultant type variable.
                        let mut lambda_type = expr.expr.type_variable.clone();
                        for param in param_types.iter().rev() {
                            let lambda_step_type = TypeVariable::Unknown(TypeVariableId::default());
                            expr.constraints.0.push((
                                lambda_step_type.clone(),
                                Constraint::Equality(TypeVariable::Function(
                                    Box::new(TypeVariable::Unknown(*param)),
                                    Box::new(lambda_type),
                                )),
                            ));
                            lambda_type = lambda_step_type;
                        }
                        expr.constraints
                            .0
                            .push((type_variable.clone(), Constraint::Equality(lambda_type)));

                        // Let's now remove and process the assumptions about the parameters.
                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let param_assumptions = params
                            .iter()
                            .map(|param| expr.assumptions.0.remove(&param.name))
                            .map(|option| option.unwrap_or(vec![]))
                            .collect::<Vec<_>>();
                        for (assumptions, param_type) in
                            param_assumptions.into_iter().zip(param_types)
                        {
                            for assumption in assumptions {
                                expr.constraints.0.push((
                                    TypeVariable::Unknown(param_type),
                                    Constraint::Equality(TypeVariable::Unknown(assumption.0)),
                                ));
                            }
                        }

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable,
                                contents: ExpressionContents::Lambda {
                                    params,
                                    expr: Box::new(expr.expr),
                                },
                            },
                            assumptions: expr.assumptions,
                            constraints: expr.constraints,
                        }
                    })
                })
        }
        ExpressionP::Let {
            identifier,
            left_expr,
            right_expr,
            ..
        } => {
            parse_expr(
                module_path,
                project_index,
                args,
                monotype_variables.clone(),
                polytype_variables.clone(),
                *left_expr,
            )
            .bind(|left_expr| {
                // This introduces new polytype variables, so we'll need to edit the `polytype_variables` map.
                let mut messages = Vec::new();
                let identifier_type = TypeVariableId::default();

                let IdentifierP { name, range } = &identifier;
                match polytype_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(module_path, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        if let Some(previous) = monotype_variables.get(name) {
                            messages.push(already_defined(module_path, *range, previous.range));
                        }
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: identifier_type,
                        });
                    }
                }

                DiagnosticResult::ok_with_many((), messages).bind(|_| {
                    parse_expr(
                        module_path,
                        project_index,
                        args,
                        monotype_variables.clone(),
                        polytype_variables.clone(),
                        *right_expr,
                    )
                    .map(|mut right_expr| {
                        // First, let's remove and store the assumptions about the variable that we created in this let statement.
                        let let_assumptions = right_expr
                            .assumptions
                            .0
                            .remove(&identifier.name)
                            .unwrap_or_else(Vec::new);

                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let mut constraints = left_expr.constraints.union(right_expr.constraints);

                        constraints.0.push((
                            TypeVariable::Unknown(identifier_type),
                            Constraint::Equality(left_expr.expr.type_variable.clone()),
                        ));

                        for assumption in let_assumptions {
                            constraints.0.push((
                                TypeVariable::Unknown(assumption.0),
                                Constraint::ImplicitInstance {
                                    scheme: TypeVariable::Unknown(identifier_type),
                                    monotypes: monotype_variables
                                        .values()
                                        .map(|monotype| monotype.var_type)
                                        .collect(),
                                },
                            ));
                        }

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable: right_expr.expr.type_variable.clone(),
                                contents: ExpressionContents::Let {
                                    identifier,
                                    left_expr: Box::new(left_expr.expr),
                                    right_expr: Box::new(right_expr.expr),
                                },
                            },
                            assumptions: left_expr.assumptions.union(right_expr.assumptions),
                            constraints,
                        }
                    })
                })
            })
        }
    }
}

/// Returns an error message saying a variable was already defined.
fn already_defined(module_path: &ModulePath, range: Range, previous_range: Range) -> ErrorMessage {
    ErrorMessage::new_with(
        String::from("a variable with this name was already defined"),
        Severity::Error,
        Diagnostic::at(module_path.clone(), range),
        HelpMessage {
            message: String::from("previously defined here"),
            help_type: HelpType::Note,
            diagnostic: Diagnostic::at(module_path.clone(), previous_range),
        },
    )
}

/// Deduces the type of an expression.
/// Any error messages are added to the diagnostic result.
///
/// This mostly implements the algorithm from Generalizing Hindley-Milner Type Inference Algorithms (2002)
/// <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348>.
fn solve_type_constraints(
    module_path: &ModulePath,
    project_index: &ProjectIndex,
    args: &HashMap<String, BoundVariable>,
    expr: ExpressionT,
    constraints: Constraints,
) -> DiagnosticResult<Expression> {
    println!("Deducing type of {:#?}", expr);
    println!("Constraints: {:#?}", constraints);
    // We implement the `SOLVE` algorithm from the above paper.

    // The substitutions are defined to be idempotent, so a map instead of an ordered vec shall suffice.
    let mut substitution = HashMap::<TypeVariableId, TypeVariable>::new();
    let mut constraint_queue = constraints
        .0
        .into_iter()
        .collect::<VecDeque<(TypeVariable, Constraint)>>();
    // To solve the constraints, we will pop entries off the front of the queue, process them, and if needed push them to the back of the queue.
    while let Some((type_variable, constraint)) = constraint_queue.pop_front() {
        match constraint {
            Constraint::Equality(other) => {
                // This constraint specifies that `type_variable === other`.
                // So we'll find the most general unifier between the two types.
                match most_general_unifier(type_variable, other) {
                    Ok(mgu) => {
                        // Add this substitution to the list of substitutions,
                        // and also apply the substitution to the current list of constraints.
                        apply_substitution_to_constraints(&mgu, &mut constraint_queue);
                        substitution.extend(mgu);
                    }
                    Err(UnificationError::TypeMismatch { left, right }) => {
                        return DiagnosticResult::fail(ErrorMessage::new(
                            format!("types {} and {} did not match", left, right),
                            Severity::Error,
                            Diagnostic::at(
                                module_path.clone(),
                                Location { line: 0, col: 0 }.into(),
                            ),
                        ));
                    }
                    Err(UnificationError::WasNotFunction { ty }) => {
                        return DiagnosticResult::fail(ErrorMessage::new(
                            format!("type {} was not a function", ty),
                            Severity::Error,
                            Diagnostic::at(
                                module_path.clone(),
                                Location { line: 0, col: 0 }.into(),
                            ),
                        ));
                    }
                }
            }
            Constraint::ExplicitInstance { .. } => unimplemented!(),
            Constraint::ImplicitInstance { scheme, monotypes } => {
                // Instantiate the given type scheme with respect to the given monotypes.
                // First, work out what the free variables are in the type scheme.
                let free_scheme = freevars(&scheme);
                let polytype_variables = free_scheme
                    .difference(&monotypes)
                    .copied()
                    .collect::<HashSet<_>>();
                let active = activevars(&constraint_queue);
                if polytype_variables.intersection(&active).next().is_some() {
                    // The variables are still live. Delay solving this constraint.
                    constraint_queue.push_back((
                        type_variable,
                        Constraint::ImplicitInstance { scheme, monotypes },
                    ));
                } else {
                    // The variables are not live. We can solve this constraint now.
                    // For each polytype variable, generate a new monotype variable to substitute for it.
                    let mut instantiate = HashMap::<TypeVariableId, TypeVariable>::new();
                    for v in polytype_variables {
                        instantiate.insert(v, TypeVariable::Unknown(TypeVariableId::default()));
                    }
                    let mut generalised_instance = type_variable.clone();
                    apply_substitution(&instantiate, &mut generalised_instance);
                    constraint_queue
                        .push_back((type_variable, Constraint::Equality(generalised_instance)));
                }
            }
        }
    }
    println!("Substitution: {:#?}", substitution);

    DiagnosticResult::ok(Expression {
        ty: Type::Variable("test".to_string()),
        contents: ExpressionContents::Symbol(QualifiedName {
            module_path: ModulePath(vec!["test".into()]),
            name: "test".into(),
            range: Location { line: 0, col: 0 }.into(),
        }),
    })
}

fn freevars(ty: &TypeVariable) -> HashSet<TypeVariableId> {
    match ty {
        TypeVariable::Known(_) => HashSet::new(),
        TypeVariable::Function(l, r) => {
            let mut result = freevars(&l);
            result.extend(freevars(&r));
            result
        }
        TypeVariable::Unknown(x) => {
            let mut result = HashSet::new();
            result.insert(*x);
            result
        }
    }
}

fn activevars(constraint_queue: &VecDeque<(TypeVariable, Constraint)>) -> HashSet<TypeVariableId> {
    let mut result = HashSet::new();
    for (ty, constraint) in constraint_queue {
        result.extend(freevars(ty));
        match constraint {
            Constraint::Equality(other) => {
                result.extend(freevars(other));
            }
            Constraint::ExplicitInstance { .. } => unimplemented!(),
            Constraint::ImplicitInstance { scheme, monotypes } => {
                result.extend(freevars(scheme).intersection(monotypes));
            }
        }
    }
    result
}

fn apply_substitution_to_constraints(
    mgu: &HashMap<TypeVariableId, TypeVariable>,
    constraint_queue: &mut VecDeque<(TypeVariable, Constraint)>,
) {
    for (ty, constraint) in constraint_queue {
        apply_substitution(mgu, ty);
        match constraint {
            Constraint::Equality(other) => apply_substitution(mgu, other),
            Constraint::ExplicitInstance { scheme } => apply_substitution(mgu, scheme),
            Constraint::ImplicitInstance { scheme, monotypes } => {
                apply_substitution(mgu, scheme);
                let original_monotypes = std::mem::take(monotypes);
                monotypes.extend(original_monotypes.into_iter().map(|monotype| {
                    let mut ty = TypeVariable::Unknown(monotype);
                    apply_substitution(mgu, &mut ty);
                    if let TypeVariable::Unknown(monotype) = ty {
                        monotype
                    } else {
                        panic!("substitution converted a monotype into a bound variable");
                    }
                }));
            }
        }
    }
}

fn apply_substitution(sub: &HashMap<TypeVariableId, TypeVariable>, ty: &mut TypeVariable) {
    if let TypeVariable::Unknown(val) = ty {
        if let Some(sub_value) = sub.get(val) {
            *ty = sub_value.clone();
        }
    }
}

enum UnificationError {
    TypeMismatch { left: Type, right: Type },
    WasNotFunction { ty: Type },
}

/// Returns a substitution which unifies the two types. If one could not be found, this is a type error, and None will be returned.
fn most_general_unifier(
    left: TypeVariable,
    right: TypeVariable,
) -> Result<HashMap<TypeVariableId, TypeVariable>, UnificationError> {
    // If one of them is an unknown type variable, just set it to the other one.
    match left {
        TypeVariable::Known(left) => {
            match right {
                TypeVariable::Known(right) => {
                    // Both type variables are known.
                    // Check that they are the same.
                    if left == right {
                        Ok(HashMap::new())
                    } else {
                        Err(UnificationError::TypeMismatch { left, right })
                    }
                }
                TypeVariable::Unknown(right) => {
                    let mut map = HashMap::new();
                    map.insert(right, TypeVariable::Known(left));
                    Ok(map)
                }
                TypeVariable::Function(right_param, right_result) => {
                    // Check that the `left` type is a function.
                    // Then we can unify its parameter and its result.
                    if let Type::Function(left_param, left_result) = left {
                        let mut mgu1 =
                            most_general_unifier(*right_param, TypeVariable::Known(*left_param))?;
                        let mgu2 =
                            most_general_unifier(*right_result, TypeVariable::Known(*left_result))?;
                        mgu1.extend(mgu2);
                        Ok(mgu1)
                    } else {
                        Err(UnificationError::WasNotFunction { ty: left })
                    }
                }
            }
        }
        TypeVariable::Unknown(left) => {
            let mut map = HashMap::new();
            map.insert(left, right);
            Ok(map)
        }
        TypeVariable::Function(left_param, left_result) => {
            match right {
                TypeVariable::Known(right) => {
                    // Check that the `right` type is a function.
                    // Then we can unify its parameter and its result.
                    if let Type::Function(right_param, right_result) = right {
                        let mut mgu1 =
                            most_general_unifier(*left_param, TypeVariable::Known(*right_param))?;
                        let mgu2 =
                            most_general_unifier(*left_result, TypeVariable::Known(*right_result))?;
                        mgu1.extend(mgu2);
                        Ok(mgu1)
                    } else {
                        Err(UnificationError::WasNotFunction { ty: right })
                    }
                }
                TypeVariable::Function(right_param, right_result) => {
                    // Both were functions. Unify both the parameters and the results.
                    let mut mgu1 = most_general_unifier(*left_param, *right_param)?;
                    let mgu2 = most_general_unifier(*left_result, *right_result)?;
                    mgu1.extend(mgu2);
                    Ok(mgu1)
                }
                TypeVariable::Unknown(right) => {
                    let mut map = HashMap::new();
                    map.insert(right, TypeVariable::Function(left_param, left_result));
                    Ok(map)
                }
            }
        }
    }
}
